<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Rust in High Frequency Trading - Sander in 't Veld</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="bt-theme.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="bt-highlight.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
<h2 class="r-fit-text">Rust <span class="mark">in High Frequency Trading</span></h2>

<p align="right">30 July 2025</p>
<p align="right">Sander in 't Veld</p>
<p align="right">Rust Meetup <span class="mark">@ BlockTech</span></p>
				</section>


				<section>
<!-- When I joined, I was unsure how much Rust I'd really be writing. -->
<!-- TODO turn into a graph -->
<!-- TODO check these numbers -->
<img src="graph_languages.png"></img>
				</section>


				<section>
<pre><code data-line-numbers class="language-sql">
<script type="text/template">SELECT t.transaction_time,
	t.price,
	t.size,
	o.component_id,
	o.order_id
FROM risk.private_trades t
LEFT JOIN execution.orders o
  ON t.transaction_time = o.transaction_time
</script></code></pre>
<pre><code data-line-numbers class="language-python">
<script type="text/template">class PrivateTrade:
	price: float
	size: float
	transaction_time: datetime
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">struct Order {
	component_id: u64,
	order_id: u64,
	transaction_time: SystemTime,
}
</script></code></pre>
				</section>


				<section data-markdown>
					<textarea data-template>
						### </span>
						- Fun
						- Challenging
						- Fast
						- Safe
						- Ambitious
						- Focus on what matters
						- Work with amazing tools
						- Smart people from different fields
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why I enjoy working here</span>
						- Fun
						- Challenging
						- Fast
						- Safe
						- Ambitious
						- Focus on what matters
						- Work with amazing tools
						- Smart people from different fields
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why Rust is great <span class="mark">in HFT</span>
						- Fun
						- Challenging
						- Fast
						- Safe
						- Ambitious
						- Focus on what matters
						- Work with amazing tools
						- Smart people from different fields
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why Rust is great <span class="mark">in HFT</span>
						- Fast
							- 1 second is a very busy exchange
							- 250 ms is the average human reaction speed
							- 65 ms for light to cross the globe
							- 1 ms
							- 100 us
							- 10 us
							- 1 us for a thread context switch
							- 100ns is too slow to compete with FPGAs
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why Rust is great <span class="mark">in HFT</span>
						- Safe
							- No segfaults
							- No buffer overflows*
							- No uninitialized data*
							- No memory leaks
						- Focus on what matters
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why Rust is great <span class="mark">in HFT</span>
						- Work with amazing tools
							- Cargo.toml
							- serde
							- cargo fmt
							- cargo clippy
							- cargo asm
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why <span class="mark">Rust in HFT</span> is great
						- Smart people from different fields
							- Mathematicians
							- Data analysts
							- Economists
							- Nerds

Α α, Β β, <span class="mark">Γ</span> γ, <span class="mark">Δ</span> δ, Ε <span class="mark">ε</span>, Ζ ζ, Η η, <span class="mark">Θ</span> θ, Ι ι,

Κ κ, Λ <span class="mark">λ</span>, Μ <span class="mark">μ</span>, Ν ν, Ξ ξ, Ο ο, Π <span class="mark">π</span>, <span class="mark">Ρ</span> ρ,

Σ <span class="mark">σ</span> ς, Τ τ, Υ υ, Φ φ, Χ χ, Ψ ψ, Ω ω, <span class="mark">Ⅎ?</span>
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why <span class="mark">Rust in HFT</span> is great
						- Fun
						- Challenging
					</textarea>
				</section>


				<section data-markdown>
					<textarea data-template>
						### Why <span class="mark">Rust in HFT</span> is great
						- Fast
						- Safe
						- Ambitious
					</textarea>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id,
        delta: f32, gamma: f32,
        theta: f32, vega: f32);

    pub fn total_delta(&self) -> f32;
    pub fn total_gamma(&self) -> f32;
    pub fn total_theta(&self) -> f32;
    pub fn total_vega(&self) -> f32;
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">    // ...
    let delta = calculate_delta(strike, forward);
    let gamma = calculate_gamma(strike, forward);
    let vega = calculate_vega(strike, forward);
    worker.update(id, delta, gamma, vega, 0.0);
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id,
        delta: f32, gamma: f32,
        theta: f32, vega: f32);

    // ...
}
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">    // ...
    let delta = calculate_delta(strike, forward);
    let gamma = calculate_gamma(strike, forward);
    let vega = calculate_vega(strike, forward);
    worker.update(id, delta, gamma, vega, 0.0);
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">#[derive(Clone, Copy)]
pub struct Greeks {
    pub delta: f32,
    pub gamma: f32,
    pub theta: f32,
    pub vega: f32,
}
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">    // ...
    let greeks = Greeks {
        delta: calculate_delta(strike, forward),
        gamma: calculate_gamma(strike, forward),
        vega: calculate_vega(strike, forward),
        theta: 0.0,
    };
    worker.update(id, greeks);
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">#[derive(Clone, Copy)]
pub struct Greeks {
    pub delta: f32,
    pub gamma: f32,
    pub theta: f32,
    pub vega: f32,
}
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id, greeks: Greeks);

    pub fn total_delta(&self) -> f32;
    pub fn total_gamma(&self) -> f32;
    pub fn total_theta(&self) -> f32;
    pub fn total_vega(&self) -> f32;
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">pub fn update(&mut self, id: Id, 
        delta: f32, gamma: f32,
        theta: f32, vega: f32) {
    // ...
    entry.greeks = Greeks { delta, gamma, theta, vega };
</script></code></pre>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">	vmovss dword ptr [rax + r8 - 20], xmm0
	vmovss dword ptr [rax + r8 - 16], xmm1
	vmovss dword ptr [rax + r8 - 12], xmm2
	vmovss dword ptr [rax + r8 - 8], xmm3
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">pub fn update(&mut self, id: Id, greeks: Greeks) {
    // ...
    entry.greeks = greeks;
</script></code></pre>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">	vmovups xmm0, xmmword ptr [rdx]
	vmovups xmmword ptr [rax + r9 - 20], xmm0
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id,
        delta: f32, gamma: f32,
        theta: f32, vega: f32);

    pub fn total_delta(&self) -> f32;
    pub fn total_gamma(&self) -> f32;
    pub fn total_theta(&self) -> f32;
    pub fn total_vega(&self) -> f32;
}
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id, greeks: Greeks);

    pub fn total_delta(&self) -> f32;
    pub fn total_gamma(&self) -> f32;
    pub fn total_theta(&self) -> f32;
    pub fn total_vega(&self) -> f32;
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">#[derive(Clone, Copy)]
pub struct Id(pub u32);

#[derive(Clone, Copy)]
pub struct Delta(pub f32);

#[derive(Clone, Copy)]
pub struct Gamma(pub f32);

#[derive(Clone, Copy)]
pub struct Theta(pub f32);

#[derive(Clone, Copy)]
pub struct Vega(pub f32);
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">#[derive(Clone, Copy)]
pub struct Greeks {
    pub delta: Delta,
    pub gamma: Gamma,
    pub theta: Theta,
    pub vega: Vega,
}
</script></code></pre>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker {
    pub fn update(&mut self, id: Id, greeks: Greeks);

    pub fn total_delta(&self) -> Delta;
    pub fn total_gamma(&self) -> Gamma;
    pub fn total_theta(&self) -> Theta;
    pub fn total_vega(&self) -> Vega;
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">pub struct Worker {
    greeks: Vec<InstrumentData>,
}

impl Worker {
    fn update(&mut self, id: Id, greeks: Greeks) {
        if let Some(entry) =
            self.greeks.iter_mut().find(|x| x.id == id)
        {
            entry.greeks = greeks;
        } else {
            self.greeks.push(InstrumentData { id, greeks });
        }
    }
    // ...
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">pub struct NaiveWorker {
    greeks: Vec<InstrumentData>,
}

pub struct HashMapWorker {
    greeks: std::collections::HashMap<Id, Greeks>,
}

pub trait Worker {
    fn update(&mut self, id: Id, greeks: Greeks);

    fn total_delta(&self) -> Delta;
    fn total_gamma(&self) -> Gamma;
    fn total_theta(&self) -> Theta;
    fn total_vega(&self) -> Vega;
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">use derive_more::{Add, AddAssign, Sum};

#[derive(Clone, Copy, PartialEq, Eq, Hash)]
pub struct Id(pub u32);

#[derive(Clone, Copy, Add, AddAssign, Sum)]
pub struct Delta(pub f32);

#[derive(Clone, Copy, Add, AddAssign, Sum)]
pub struct Gamma(pub f32);

#[derive(Clone, Copy, Add, AddAssign, Sum)]
pub struct Theta(pub f32);

#[derive(Clone, Copy, Add, AddAssign, Sum)]
pub struct Vega(pub f32);
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">pub struct HashMapWorker {
    greeks: std::collections::HashMap<Id, Greeks>,
}

impl Worker for HashMapworker {
    fn update(&mut self, id: Id, greeks: Greeks) {
        self.greeks.insert(id, greeks);
    }

    fn total_delta(&self) -> Delta {
        self.greeks.values().map(|x| x.delta).sum()
    }

    fn total_gamma(&self) -> Gamma {
        self.greeks.values().map(|x| x.gamma).sum()
    }
    // ...
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">    // ...
    let total_greeks = Greeks {
        delta: self.total_delta(),
        gamma: self.total_gamma(),
        theta: self.total_theta(),
        vega: self.total_vega(),
    };
    // ...
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">impl Worker for HashMapworker {
    // ...
    fn total_greeks(&self) -> Greeks {
        let mut total = Greeks {
            delta: Delta(0.0),
            gamma: Gamma(0.0),
            theta: Theta(0.0),
            vega: Vega(0.0),
        };
        for entry in self.greeks.values() {
            total.delta += entry.delta;
            total.gamma += entry.gamma;
            total.theta += entry.theta;
            total.vega += entry.vega;
        }
        total
    }
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">fn bench_worker(c: &mut Criterion,
    mut worker: impl Worker + Default
) {
    const N: usize = 10_000;
    let mut rng = rand::rng();
    let mut updates: Vec<(Id, Greeks)>;
    // ...
    g.bench_function("insert", |b| {
        updates.shuffle(&mut rng);
        worker = Default::default();
        b.iter(|| {
            for &update in std::hint::black_box(&updates) {
                let (id, greeks) = update;
                worker.update(id, greeks);
            }
        })
    });
    // ...
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">fn bench_worker(c: &mut Criterion,
    mut worker: impl Worker + Default
) {
    // ...

    g.bench_function("total_delta", |b| {
        b.iter(|| worker.total_delta())
    });
    g.bench_function("total_greeks", |b| {
        b.iter(|| worker.total_greeks())
    });
}

fn bench_naive_worker(c: &mut Criterion) {
    bench_worker(c, NaiveWorker::default())
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">NaiveWorker/insert
                    time:   [23.015 ms 23.036 ms 23.059 ms]
NaiveWorker/update
                    time:   [23.086 ms 23.109 ms 23.135 ms]
NaiveWorker/total_delta
                    time:   [9.1201 µs 9.1295 µs 9.1403 µs]
NaiveWorker/total_greeks
                    time:   [36.419 µs 36.445 µs 36.474 µs]
</script></code></pre>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">HashMapWorker/insert
                    time:   [126.84 µs 126.97 µs 127.13 µs]
HashMapWorker/update
                    time:   [125.33 µs 125.41 µs 125.49 µs]
HashMapWorker/total_delta
                    time:   [11.332 µs 11.393 µs 11.457 µs]
HashMapWorker/total_greeks
                    time:   [9.4612 µs 9.5135 µs 9.5685 µs]
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-rust">
<script type="text/template">use fxhash::FxHashMap;

#[derive(Default)]
pub struct FxHashWorker {
    greeks: FxHashMap<Id, Greeks>,
}
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">HashMapWorker/insert
                    time:   [126.84 µs 126.97 µs 127.13 µs]
HashMapWorker/update
                    time:   [125.33 µs 125.41 µs 125.49 µs]
HashMapWorker/total_delta
                    time:   [11.332 µs 11.393 µs 11.457 µs]
HashMapWorker/total_greeks
                    time:   [9.4612 µs 9.5135 µs 9.5685 µs]
</script></code></pre>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">FxHashWorker/insert
                    time:   [52.554 µs 52.612 µs 52.673 µs]
FxHashWorker/update
                    time:   [53.654 µs 53.842 µs 54.045 µs]
FxHashWorker/total_delta
                    time:   [9.2757 µs 9.2938 µs 9.3141 µs]
FxHashWorker/total_greeks
                    time:   [9.2781 µs 9.2893 µs 9.3029 µs]
</script></code></pre>
				</section>


				<section>
<pre><code data-line-numbers class="language-x86asm">
<script type="text/template">	.p2align	4
.LBB40_2:
	vaddps ymm15, ymm15, ymmword ptr [rax]
	vaddps ymm14, ymm14, ymmword ptr [rax + 32]
	vaddps ymm13, ymm13, ymmword ptr [rax + 64]
	vaddps ymm12, ymm12, ymmword ptr [rax + 96]
; ...
	vaddps ymm2, ymm2, ymmword ptr [rax + 416]
	vaddps ymm1, ymm1, ymmword ptr [rax + 448]
	vaddps ymm0, ymm0, ymmword ptr [rax + 480]
	add rcx, -128
	add rax, 512
	cmp rcx, 127
	ja .LBB40_2
</script></code></pre>
				</section>



				<section data-markdown>
					<textarea data-template>
						### Why <span class="mark">Rust in HFT</span> is great
						- Fun
						- Challenging
						- Fast
						- Safe
						- Ambitious
						- Focus on what matters
						- Work with amazing tools
						- Smart people from different fields
					</textarea>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
